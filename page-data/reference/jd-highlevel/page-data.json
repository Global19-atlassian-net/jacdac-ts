{"componentChunkName":"component---src-components-spec-tsx","path":"/reference/jd-highlevel/","result":{"data":{"mdx":{"id":"41d46fe5-6c4d-5cf9-ac70-ba79f195053f","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Protocol Specification\",\n  \"order\": 4\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h2\", {\n    \"id\": \"protocol-specification\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", _extends({\n    parentName: \"h2\"\n  }, {\n    \"href\": \"#protocol-specification\",\n    \"aria-label\": \"protocol specification permalink\",\n    \"className\": \"anchor before\"\n  }), mdx(\"svg\", _extends({\n    parentName: \"a\"\n  }, {\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }), mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), \"Protocol Specification\"), mdx(\"p\", null, \"JACDAC (Joint Asynchronous Communication; Device Agnostic Control) is a new protocol designed to make it easier to connect low cost microcontrollers and sensors together. JACDAC is not only designed for easier physical connectivity, it is an entire hardware and software stack that bridges the world of the low cost microcontroller to the web browser and beyond.  Read more about the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"../motivation\"\n  }), \"motivation for JACDAC\"), \".\"), mdx(\"p\", null, \"A JACDAC device is any device that  generates its own unique \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"../device-identity\"\n  }), \"device identifier\"), \" and implements the JACDAC protocol. The protocol consists of three core layers:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"(optional) The \", mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"../service-layer\"\n  }), \"service layer\"), \"\\u2013\\u2013How JACDAC devices share hardware or software resources with one another.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"The \", mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"../transport-layer\"\n  }), \"transport layer\"), \"\\u2013\\u2013Responsible for reliably routing packets to and from services and applications.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"The \", mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"../physical-layer\"\n  }), \"physical layer\"), \"\\u2013\\u2013Transmits and receives packets from other JACDAC devices.\")), mdx(\"h3\", {\n    \"id\": \"service-layer\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", _extends({\n    parentName: \"h3\"\n  }, {\n    \"href\": \"#service-layer\",\n    \"aria-label\": \"service layer permalink\",\n    \"className\": \"anchor before\"\n  }), mdx(\"svg\", _extends({\n    parentName: \"a\"\n  }, {\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }), mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), \"Service Layer\"), mdx(\"p\", null, \"The way JACDAC devices share resources with other devices on the bus are through \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"services\"), \". Services provide abstract, standardized interfaces that can be used to interact with physical hardware resources (e.g. an accelerometer) or pure virtual resources (e.g. the state of a video game). This abstraction brings plug-and-play dynamism to JACDAC so that devices with different hardware, but the same overall functionality, can replace one another without having to recompile user applications. For example, two different models of accelerometer hardware can replace each other because they share the same software interface. \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"../service-layer\"\n  }), \"Read more about the service layer\")), mdx(\"p\", null, \"Any device that hosts a service must also run the control service. The control service is responsible for advertising any services a device is running every 500 milliseconds. Like any other service, the packets emitted by the control service are standardized. There also a set of common commands that must be implemented by JACDAC devices that operate services, including functionality like \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"reset\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"time since boot\"), \".\"), mdx(\"p\", null, \"Most JACDAC users will never need to write a service: the major use case is for users to write applications that interact with JACDAC devices and services. Using JACDAC in microcontroller applications is incredibly easy and only requires a software stack that has a compatible JACDAC physical layer.\"), mdx(\"p\", null, \"Services are registered in the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"../../services\"\n  }), \"service catalog\"), \" and described by \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"../service-specification\"\n  }), \"service specifications\"), \".\"), mdx(\"h3\", {\n    \"id\": \"transport-layer\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", _extends({\n    parentName: \"h3\"\n  }, {\n    \"href\": \"#transport-layer\",\n    \"aria-label\": \"transport layer permalink\",\n    \"className\": \"anchor before\"\n  }), mdx(\"svg\", _extends({\n    parentName: \"a\"\n  }, {\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }), mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), \"Transport Layer\"), mdx(\"p\", null, \"Whenever a frame is received by the physical layer, the transport layer divides that frame into data packets and forwards them to the appropriate service or user application. At this point, services and applications can use packets to perform actions based on new data.\"), mdx(\"p\", null, \"In many cases it is important that data is received by a specific device. JACDAC supports this mechanism using acknowledgements and pipes. Acknowledgements are incredibly simple and require receiving devices to recognise that a frame has successfully been received. Pipes on the other hand set up a point to point connection between devices, and every packet is acknowledged and received using a sliding window approach. Only the most capable devices are expected to support pipes.\"), mdx(\"p\", null, mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"../transport-layer\"\n  }), \"Read more about the transport layer.\")), mdx(\"h3\", {\n    \"id\": \"physical-layer\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", _extends({\n    parentName: \"h3\"\n  }, {\n    \"href\": \"#physical-layer\",\n    \"aria-label\": \"physical layer permalink\",\n    \"className\": \"anchor before\"\n  }), mdx(\"svg\", _extends({\n    parentName: \"a\"\n  }, {\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }), mdx(\"path\", _extends({\n    parentName: \"svg\"\n  }, {\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), \"Physical Layer\"), mdx(\"p\", null, \"In the future there will be many physical layer implementations responsible for sending frames across a wired or wireless communication medium. Frames contain one or more packets, and packets contain a service command or report. Frames also have addressing metadata embedded inside them that the transport layer uses to route packets correctly.\"), mdx(\"p\", null, \"For communicating across a single wire, devices should observe the Single Wire Serial (SWS) communication standard. \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"../physical-layer\"\n  }), \"Read more about the SWS standard here.\")));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"title":"Protocol Specification"}}},"pageContext":{"id":"41d46fe5-6c4d-5cf9-ac70-ba79f195053f"}},"staticQueryHashes":["2214083594","2270080012","2461311362","2744294623","3159585216","413816803","63159454"]}